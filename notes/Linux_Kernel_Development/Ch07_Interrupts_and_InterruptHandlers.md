# Chapter 7: [Interrupts and Interrupt Handlers]

## **Summary**
- The core responsibility of any operating system kernel is to manage the hardware connected to the machine. To meet this responsibility, the kernel needs to communicate with the machine's individual devices(hardware).
- As the processor is much faster than the connected hardware, it is not ideal for kernel to issue a request to the connected hardware and wait for its response. Instead, because the hardware is comparatively slow to respond, the kernel must be free to go and handle other work, dealing with the hardware only after the hardware has completed its work.
- This can be achieved in two ways:
	- **Polling:** The kernel can periodically check the status of the hardware and respond accordingly. Polling induces overhead as it must occur repeatedly regardless of whether the hardware is active or not.
	- **Interrupt:** A mechanism for the hardware to signal to the kernel when attention is needed.

### **Interrupts**
- Interrupts enable hardware to signal to the processor. For example, as you press a key in the keyboard, the keyboard controller (the hardware device that manages the keyboard) issues an electrical signal to the processor to alert the operating system that a new key press is available. These electrical signals are interrupts.
- On receiving the interrupt, the processor signals to the operating system so that the operating system can respond to the new data.
- Hardware devices generate interrupts asynchronously with respect to the processor clock - they can occur at any time.
- **How does the processor know that an interrupt has come?**
	- An interrupt is physically produced by electronic signals originating from the hardware devices and directed into input pins on an interrupt controller (a simple chip that multiplexes interrupt lines into a single line to the processor).
	- Upon receiving an interrupt, the interrupt controller sends a signal to the processor.
	- The processor detects this signal and interrupts its current execution to handle the interrupt. The processor then notifies the operating system, and the operating system will handle the interrupt appropriately.
- **How does the operating know which hardware device caused the which interrupt?**
	- Different devices can be associated with different interrupts by means of a unique value associated with each interrupt. These interrupt values are often called *interrupt request (IRQ)* lines.
	- Each IRQ line is assigned a numeric value. For example, on the classic PC, IRQ zero is the timer interrupt and IRQ one is the keyboard interrupt.
	- Not all interrupt numbers are rigidly defined. For example, interrupts associated with devices on the PCI bus, generally, are dynamically assigned.
	- This enables the operating system to differentiate between interrupts and to know which hardware device caused which interrupt.
	- Operating system can service each interrupt with its corresponding handler.
- #### Exceptions
	- Unlike interrupts, *exceptions* occur synchronously with respect to the processor clock. They are often called *synchronous interrupts*. 
	- Exceptions are produced by the processor while executing instructions either in response to a programming error (for example, divide by zero) or abnormal conditions that must be handled by the kernel (for example, a page fault).
	- The kernel infrastructure of handling an interrupt and an exception is similar.
	- In short,
		- Interrupts : Asynchronous interrupts generated by hardware.
		- Exceptions : Synchronous interrupts generated by the processor.
	- Example:
		  We have seen in the previous chapter [[Ch05_SystemCalls]], how system calls on the x86 architecture are implemented by the issuance of a software interrupt, which traps into the kernel and causes exception of a special system call handler.

### **Interrupt Handlers**
- The function that kernel runs in response to a specific interrupt is called an *interrupt handler* or *interrupt service routine (ISR)*.
- Each device that generates interrupts has an associated interrupt handler. For example, one function handles interrupts from the system timer, whereas another function handles interrupts generated by the keyboard.
- The interrupt handler for a device is a part of the device's *driver* - the kernel code that manages the device.
- **What differentiates interrupt handlers from the other kernel functions?**
	- Kernel invokes the interrupt handlers in response to interrupts. The interrupt handlers run in a special context called *interrupt context* or *atomic context*. Code executing in this context is unable to block.
- It is important to the hardware that the operating system services the interrupt without delay, it is also important to the rest of the system that the interrupt handler executes in a short period.
- The very basic job of an interrupt handler is to inform or acknowledge the hardware upon receiving the interrupt.
- Often, however, interrupt handlers have a large amount of work to perform.
  **Example:**
  Consider the interrupt handler for a network device. On top of responding to the hardware, the interrupt handler needs to copy networking packets from the hardware into memory, process them, and push the packets down to the appropriate protocol stack or application. Obviously, this can be a lot of work, especially with today’s gigabit and 10-gigabit Ethernet cards.

### **Top Halves versus Bottom Halves**
- These two goals - that an interrupt handler execute quickly *and* perform a large amount of work - clearly conflict with one another.
- Because of these competing goals, the processing of interrupts is split into two parts, or halves. The interrupt handler is the *top half*.
- The top half is run immediately upon receipt of the interrupt and performs only the work that is time-critical, such as acknowledging the receipt of interrupt or resetting the hardware.
- Work that can be performed later is deferred until the *bottom half*. The bottom half runs in the future, at a more convenient time, with all interrupts enabled.
- **Example:**
	- When the network cards receive packet from the network, the network cards want and need to alert the kernel immediately (to optimize network throughput and latency and avoid timeouts).
	- Therefore, the network cards immediately issue an interrupt: *Hey, kernel, I have some fresh packets here!*
	- The kernel responds by executing the network card's registered interrupt.
	- The interrupt runs, acknowledges the hardware, copies the new networking packets into the main memory, and readies the network card for more packets.
	  Note: These jobs are important, time-critical, and hardware-specific work. The kernel needs to quickly copy the networking packets into the main memory because the network data buffer on the networking card is fixed and small in size as compared to the main memory. Delays in copying the packets can result in buffer overrun, with incoming packets overwhelming the network card's buffer and thus packets being dropped.
	- After the networking data is safely copied into the main memory, the interrupt's job is done, and it can return control of the system to whatever code was interrupted when the network card interrupt was generated.
	- The rest of the processing and handling of the packets occurs later, in the bottom half.

### **Registering an Interrupt Handler**
- Interrupt handlers are the responsibility of the driver managing the hardware.
- Each device has one associated driver and, if that device uses interrupt (and must do), then that driver must register one interrupt handler.
- Drivers can register an interrupt handler and enable a given interrupt line for handling with the function `request_irq()`, which is declared in `<linux/interrupt.h>`.
	```c
/* request_irq: allocate a given interrupt line */
int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
                const char *name, void *dev)
	```
- `irq` - specifies the interrupt number to allocate. For some devices such as the system timer or keyboard, this value is typically hard-coded. For most other devices, it is probed or otherwise determined programmatically and dynamically.
- `handler` - the function pointer to the actual interrupt handler that services this interrupt.
	- This function is invoked whenever the operating system receives the interrupt.
	  ```c
	  typedef irqreturn_t (*irq_handler_t)(int, void *);
		```
- `flags` - can be either zero or a bit mask of one or more of the flags defined in `<linux/interrupt.h>`. Among these flags, the most important are:
	- **IRQF_DISABLED**
		- instructs kernel to disable all interrupts when executing this interrupt handler.
		- Rarely used, as it increases interrupt latency for other devices, potentially degrading the system performance.
		- Suitable for handlers requiring absolute atomicity.
	- **IRQF_SAMPLE_RANDOM**
		- specifies that interrupts generated by this device should contribute to the kernel entropy pool.
			- What is kernel entropy?
				- Entropy in the kernel refers to a measure of randomness or unpredictability collected from various system events, used to generate high-quality random numbers.
				- The kernel maintains an entropy pool, a reservoir of random data, to supply random numbers for `/dev/random` and `/dev/urandom `devices.
				- `/dev/random`: Provides cryptographically secure random numbers, blocking if insufficient entropy is available.
				- `/dev/urandom:` Provides pseudo-random numbers, non-blocking but less secure if entropy is low.
		- The kernel entropy pool provides truly random numbers derived from various random events.
			- Why do we need random number generation in kernel?
				- Random numbers are essential for cryptographic operations, such as generating encryption keys, session IDs, or occasionally for secure communication (e.g., SSL/TLS, SSH).
				- High-quality randomness ensures keys are unpredictable, preventing attackers from guessing or cracking them.
				- They secure network protocols (e.g., TCP sequence numbers) to prevent session hijacking.
		- If this flag is specified, the timing of interrupts from this device are fed to the pool as entropy. 
		- The flag tells the kernel to sample the timestamp of the interrupt (using high-resolution timers like `ktime_get()`) and feed it into the entropy pool.
		- Devices like network cards (with packet arrivals) or input devices (with user actions) generate interrupts at irregular intervals, providing good entropy.
		- Increases the entropy pool’s size, ensuring `/dev/random `has enough data for cryptographic operations without blocking.
		- In short, this flag doesn't do any related to interrupt handling but contributes to the kernel so that the kernel's random number generation capabilities increase.
		- **NOTE:** *In modern kernels (post-book), this flag’s usage has diminished due to dedicated hardware random number generators (e.g., RDRAND on x86) or improved entropy collection, but it remains relevant for older systems or embedded devices like BeagleBone Black.*
	- **IRQF_TIMER**
		- Marks the interrupt as belonging to a timer device, such as the system clock.
		- Ensures special handling, like higher priority or protection against disabling during system suspend.
		- Critical for timekeeping and scheduling tasks in the kernel.
	- **IRQF_SHARED**
		- Allows multiple devices to share the same IRQ line, common in systems with limited IRQs.
		- Each handler must check if its device triggered the interrupt to avoid processing irrelevant events.
		- Requires careful design to prevent conflicts between handlers sharing the IRQ.
	- **IRQF_ONESHOT**
		- Used for threaded interrupts, where the handler runs in a kernel thread and is executed only once per interrupt.
	- **IRQF_NO_SUSPEND**
		- Ensures the interrupt remains enabled during system suspend, critical for wake-up devices like keyboards.
- `name` - an ASCII text representation of the device associated with the interrupt.
	- These text names are used by /proc/irq and /proc/interrupts for communication with the user.
- `dev` - is used for shared interrupt lines.
	- can pass NULL here if the line is not shared.
	- A common practice is to pass the driver’s device structure:This pointer is unique and might be useful to have within the handlers.
- On success, `request_irq()` returns zero.A nonzero value indicates an error, in which case the specified interrupt handler was not registered. A common error is `-EBUSY,` which denotes that the given interrupt line is already in use (and either the current user or you did not specify `IRQF_SHARED`).

- Due to the possibility of sleeping, `request_irq()` must be called from a process context (e.g., during driver initialization) where blocking is safe, not from interrupt handlers or other non-preemptible contexts.
- **Common Mistake**: Developers often mistakenly call `request_irq()` in contexts where blocking is not allowed, leading to potential kernel errors or crashes.
- **Reason for Blocking**:
	- `request_irq()` creates an entry in`/proc/irq` to track the interrupt for debugging (visible in `/proc/interrupts`).
	- This involves calling `proc_mkdir()` to create *procfs* entries, which uses `proc_create()`.
	- `proc_create()` calls `kmalloc()` to allocate memory for the *procfs* entry.
		- `kmalloc()` can sleep (block) if memory is not immediately available, causing `request_irq()` to potentially sleep.

- **Freeing an Interrupt Handler**
	- **Purpose**: Releases an interrupt handler to free resources when a driver is unloaded or device is removed.
	- **Function**: `void free_irq(unsigned int irq, void *dev)`
		- `irq` - IRQ number to free.
		- `dev` - Device pointer to identify handler (critical for shared IRQs).
	- **When used:** Called during driver cleanup (e.g., module exit or device removal).
	- **Safety:**
		- Disables IRQ for the handler to prevent further calls.
		- Waits for active handlers to finish, avoiding race conditions.
		- Must be called from process context (can sleep).
	- **Importance**: Prevents resource leaks and crashes from stray interrupts after driver removal.
	- **Example**: `free_irq(net_irq, net_dev)` in a network driver’s cleanup function.

### **Writing an Interrupt Handler**
- **Purpose**: Defines a kernel function to process interrupts quickly and efficiently.
- **Signature**: `irqreturn_t handler(int irq, void *dev)`
	- `irq` - IRQ number.
	- `dev` - Device-specific data pointer.
	- Returns `IRQ_HANDLED` or `IRQ_NONE`.
- **Key Requirements**:
	- Fast execution to minimize system disruption.
	- No blocking operations (e.g., sleep, I/O wait) as it runs in interrupt context.
	- Check if interrupt is for its device (for shared IRQs).
	- The interrupt handler is normally marked static because it is never called directly from another file.
- **Tasks**:
	- Acknowledge interrupt to clear it on the device.
	- Collect minimal data from device.
	- Defer non-critical work to bottom halves (e.g., softIRQs, workqueues).
- **Shared IRQs**: Handler must verify device ownership using registers.
- **Constraints**: Runs with preemption disabled, uses limited interrupt stack.
- **Example**: Network handler acknowledges packet arrival, queues processing.

### Shared Handlers
- Multiple interrupt handlers for different devices sharing a single IRQ line.
- **Flag:** `IRQF_SHARED` in `request_irq()` allows multiple handlers on one IRQ.
- **Handler Behavior**:
	- Each handler checks device-specific registers to confirm its device triggered the interrupt.
	- Returns `IRQ_NONE` if the interrupt isn’t for its device.
- **Advantage**: Supports more devices when IRQ lines are limited.
- **Challenge**: Increased complexity to avoid handler conflicts.
- **Example**: USB and network drivers sharing an IRQ; each checks its device’s status.

### **Interrupt Context**
- Special execution mode when an interrupt handler runs, distinct from process context.
- **Characteristics**:
	- Non-preemptible: Handler cannot be interrupted by other tasks.
	- No sleeping: Blocking operations (e.g., `sleep`, `mutex_lock`) are forbidden.
	- Limited stack: Uses a small, dedicated interrupt stack to avoid overflow.
- **Purpose**: Ensures fast, atomic interrupt handling without interference.
- **Constraints**:
	- Handlers must be quick to minimize system disruption.
	- Avoid operations requiring process context (e.g., scheduling, I/O waits).
- **Implication**: Non-critical tasks deferred to bottom halves (e.g., softIRQs, workqueues).
- **Example**: Network interrupt handler runs in interrupt context, queuing packet processing.

### **Implementing Interrupt Handlers**
- The implementation of the interrupt handling system in Linux is architecture-dependent.The implementation depends on the processor, the type of interrupt controller used, and the design of the architecture and machine.
 ![[Pasted image 20250615121555.png]]
- Interrupt Trigger:
	- Device sends signal to interrupt controller (e.g., PIC, APIC).
	- Controller forwards interrupt to CPU via a special pin, if enabled.
- CPU Response:
	- CPU halts task, disables interrupts, jumps to kernel’s predefined entry point.
	- Entry point saves IRQ number and registers, calls do_IRQ().
- `do_IRQ()` Function:
	- Extracts IRQ from saved registers, acknowledges interrupt (e.g., via `mask_and_ack_8259A()`).
	- Checks for valid, enabled handler, then calls `handle_IRQ_event()`.
- **handle_IRQ_event()**:
	- Re-enables interrupts (unless `IRQF_DISABLED` set).
	- Executes handler(s) in loop (once for non-shared IRQs, all for shared).
	- Adds entropy if `IRQF_SAMPLE_RANDOM` set, disables interrupts again.
- **Completion**:
	- `do_IRQ()` returns to entry point, which calls `ret_from_intr()`.
	- `ret_from_intr()` checks for rescheduling:
		- Calls `schedule()` if `need_resched` set and returning to user-space.
		- Calls `schedule()` in kernel-space only if `preempt_count` is zero.
	- Restores registers, resumes interrupted task.
- **Architecture Details**:
	- x86 assembly in `arch/x86/kernel/entry_64.S` (or `entry_32.S` for 32-bit).
	- C code in `arch/x86/kernel/irq.c`.

### **/proc/interrupts**
- Procfs is a virtual filesystem that exists only in kernel memory and is typically mounted at `/proc`. Reading or writing files in procfs invokes kernel functions that simulate reading or writing from a real file.
- procfs code is located primarily in fs/proc. The function that provides `/proc/interrupts` is, not surprisingly, architecture-dependent and named `show_interrupts()`.
- `/proc/interrupts`: Virtual file in procfs showing interrupt activity per IRQ line.
- Example:
  ![[Pasted image 20250615123817.png]]
- **Columns**:
	- **IRQ Number**: Unique ID for each interrupt line (e.g., 0 for timer).
	- **Interrupt Counts**: Number of interrupts per CPU (one column per CPU).
	- **Interrupt Type**: Indicates controller or interrupt type (e.g., IO-APIC, XT-PIC).
	- **Device Name**: Driver name from request_irq() (e.g., "eth0", "keyboard").
- **Usage**:
	- Debugs interrupt issues (e.g., missing or excessive interrupts).
	- Monitors interrupt load and CPU distribution.
- **Shared IRQs**: Lists multiple devices per IRQ if IRQF_SHARED used.
- **Example**: IRQ 1 shows keyboard, counts per CPU, "XT-PIC", "i8042".

### **Interrupt Control**
- The Linux kernel implements a family of interfaces for manipulating the state of interrupts on a machine.
- These interfaces enable you to disable the interrupt system for the current processor or mask out an interrupt line for the entire machine.
- These routines are all architecture-dependent and can be found in `<asm/system.h>` and `<asm/irq.h>`.
- **Why is it needed?**
	- To prevents interrupt handlers from preempting critical code.
- **Effects**: Disabling interrupts also disables kernel preemption.
- **Limitation**: No protection from other CPUs; requires locks for multi-processor safety.
- **Context**: Used with locks (covered in Chapters 9, 10) for full synchronization.
- #### **Disabling and Enabling Interrupts**
	- **Purpose**: Control interrupt delivery on current CPU for synchronization.
	- **Functions:**
		- `local_irq_disable()`: Disables all interrupts on current CPU.
		- `local_irq_enable()`: Re-enables interrupts on current CPU.
	- **Safe Alternative**:
		- `local_irq_save(flags)`: Saves interrupt state, disables interrupts.
		- `local_irq_restore(flags)`: Restores interrupts to saved state.
	- **Why Save/Restore**:
		- Prevents enabling interrupts if they were already disabled.
		- Safer for code paths with unknown interrupt states.
	- **Constraints**:
		- `flags` (unsigned long) stores architecture-specific interrupt state.
		- `flags` must stay in the same function (stack frame issue on SPARC).
	- **Implications**:
		- Disabling interrupts prevents handler preemption, disables kernel preemption.
		- No protection from other CPUs; needs locks for multi-processor safety.
	- **Usage**: Callable from interrupt or process context.
- #### **Disabling a Specific Interrupt Line**
	- In the previous section, we looked at functions that disable all interrupt delivery for an entire processor.
	- In some cases, it is useful to disable only a *specific* interrupt line for the entire system. This is called *masking out* an interrupt line.
	- As an example, you might want to disable delivery of a device’s interrupts before manipulating its state.
	- Linux provides four interfaces for this task:
		- `disable_irq(irq)`: Disables IRQ in the interrupt controller, waits for active handlers to finish.
		- `disable_irq_nosync(irq)`: Disables IRQ in the interrupt controller without waiting for handlers.
		- `enable_irq(irq)`: Re-enables IRQ after matching disable calls.
		- `synchronize_irq(irq)`: Waits for active handler on IRQ to complete.
	- **Nesting**: Multiple `disable_irq()/nosync` calls require equal `enable_irq()` calls.
	  For example, if `disable_irq()` is called twice, the interrupt line is not actually reenabled until the second call to `enable_irq()`.
	- **Usage**: Controls device-specific interrupts (e.g., before state changes).
	- **Context**: Safe in interrupt or process context; non-sleeping.
	- **Limitation**: Avoid for shared IRQs (e.g., PCI devices); used for legacy devices.
	- **Example**: Disable parallel port IRQ during reconfiguration.

### **Status of the Interrupted System**
- It is often useful to know the state of the interrupt system (for example, whether interrupts are enabled or disabled) or whether you are currently executing in interrupt context.
- **Purpose**: Provides functions to check interrupt system state for synchronization.
- **Key Functions**:
	- `irqs_disabled(`): Returns non-zero if interrupts are disabled on current CPU.
	- `in_interrupt()`: Returns non-zero if kernel is running in interrupt context (handler or bottom half). If returns zero, the kernel is in the process context.
	- `in_irq()`: Returns non-zero only if the kernel is specifically executing an interrupt handler. 
- **Usage**:
	- Helps drivers avoid illegal operations (e.g., sleeping in interrupt context).
	- Ensures code behaves correctly based on interrupt state.
- **Importance**: Prevents bugs by checking context before critical operations.
- **Example**: Driver checks `in_interrupt()` before scheduling work.

## **Quick Recall**
-  **Q: What is an interrupt?**
	- **A**: Signal from device or software pausing CPU to handle urgent events.
- **Q: How does** `do_IRQ(`) **work?**
     - **A**: Saves IRQ, acknowledges interrupt, calls handler via `handle_IRQ_event()`.
 - **Q: What does** `IRQF_SHARED` **flag do?**
	 - **A**: Allows multiple handlers to share one IRQ; each checks device ownership.
 - **Q: Why avoid sleeping in interrupt handlers?**
	 - **A**: Runs in interrupt context; sleeping blocks system, causes errors.
 - **Q: What is** /proc/interrupts **used for?**
	 - **A**: Shows IRQ activity, counts per CPU, and device names for debugging.
 - **Q: Difference between** `local_irq_disable()` **and** `disable_irq()`**?**
	 - **A**: `local_irq_disable()` blocks all IRQs on current CPU; `disable_irq()` blocks specific IRQ system-wide.
 - **Q: What checks** `in_interrupt()`**?**
	 - **A**: Returns non-zero if in interrupt context or bottom half.

## **Hands-on Ideas**
- **GPIO Button Interrupt**:
	- Write kernel module to handle GPIO interrupt on BBB (e.g., P9_11).
	- Register handler with request_irq(), log button presses.
	- Check /proc/interrupts for counts.
	- **Learn**: GPIO-to-IRQ mapping, handler registration.
- **Interrupt Latency Test**:
	- Create module to measure time from GPIO interrupt to handler start.
	- Use `ktime_get()` for timestamps, trigger via button.
	- Log latency under load (e.g., run stress).
	- **Learn**: Interrupt response time, system load impact.
- **Shared Interrupt Simulation**
	- Configure two GPIOs to share IRQ on BBB (check AM335x datasheet).
	- Write module with two handlers, each checking its GPIO.
	- Trigger alternately, verify correct handling.
	- **Learn**: Shared IRQ mechanics, handler validation.
- **Workqueue Bottom Half**:
	- Write module using GPIO interrupt to schedule workqueue task.
	- Handler triggers workqueue to toggle LED or log data.
	- Test with button presses
	- **Learn**: Top vs. bottom half separation.
- **Interrupt Disable Effect**:
	- Module to disable interrupts with local_irq_disable() during loop.
	- Compare loop time with interrupts enabled vs. disabled.
	- Monitor `/proc/interrupts `for suppression.
	- **Learn**: Impact of interrupt disabling on responsiveness.